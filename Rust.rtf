{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fswiss\fcharset0 Helvetica-Bold;
\f3\fnil\fcharset0 AppleColorEmoji;\f4\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red209\green209\blue209;\red72\green139\blue206;\red255\green255\blue255;
\red0\green0\blue0;\red255\green255\blue255;\red210\green210\blue209;\red255\green255\blue255;\red142\green213\blue255;
\red166\green166\blue165;\red67\green192\blue160;\red228\green228\blue224;\red212\green213\blue153;\red0\green0\blue0;
\red71\green137\blue205;\red210\green210\blue209;\red212\green213\blue154;\red165\green165\blue165;\red136\green136\blue136;
\red67\green192\blue160;\red206\green139\blue216;\red167\green197\blue151;\red141\green212\blue254;}
{\*\expandedcolortbl;;\cssrgb\c85490\c85490\c85490;\cssrgb\c34356\c61927\c84545;\cssrgb\c100000\c100000\c100000\c0;
\cssrgb\c0\c1\c1;\cssrgb\c100000\c100000\c99985\c0;\cssrgb\c85772\c85771\c85450;\cssrgb\c100000\c100000\c99971\c0;\cssrgb\c61729\c86919\c100000;
\cssrgb\c70821\c70820\c70555;\cssrgb\c30653\c78980\c69024;\cssrgb\c91362\c91358\c90118;\cssrgb\c86232\c86184\c66253;\cssrgb\c0\c0\c0\c0;
\cssrgb\c33936\c61427\c84130;\cssrgb\c85585\c85584\c85478;\cssrgb\c86261\c86245\c66529;\cssrgb\c70666\c70666\c70578;\cssrgb\c60459\c60459\c60383;
\cssrgb\c30610\c78876\c69022;\cssrgb\c84873\c62914\c87542;\cssrgb\c71008\c80807\c65805;\cssrgb\c61361\c86489\c99746;}
\paperw11900\paperh16840\margl1440\margr1440\vieww17600\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs36 \cf0 1. cargo	init : to initialise existing directory as rust project.\
\
2. cargo	run : to run rust file.\
\
3. let mut x : i32 = 23;\
    let name = String :: from(\'93Sujal\'94);\
\
4. let char1 = name.chars().nth(0).unwrap();    use this if you are sure that this char will exist.\
\
5. https://doc.rust-lang.org/stable/book/title-page.html  : Rust documentation
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
\

\f0\fs36 \cf0 \kerning1\expnd0\expndtw0 \
6. Rust does not allow you to have undefined items.\
\
7. Memory management in rust vs c vs other languages.\
\
8. Rust does not have garbage collector.\
\
9. Storing data in stack memory is fast b/c in heap compiler has to ask OS again and again 	for the space.\
\
10. p = &num ; \
println!("Pointer address: \{:p\}", ptr);  // address\
println!("Pointer address: \{\}\'94, *ptr);   // value at that address\
\
11. Use std :: io\
\
12. Take input and print that number\
\pard\pardeftab720\partightenfactor0

\f1 \cf3 \cb4 \expnd0\expndtw0\kerning0
\

\fs28 \cf5 \cb6 let mut \ul \ulc5 input\ulnone  = String::new();\
    println!("Enter an number : ");\
    io::stdin().read_line(&mut \ul input\ulnone ).expect("Failed");\
    let num : i32 = \ul input\ulnone .trim().parse().expect("Please type a number");\
    println!("\{\}",num);\
\}
\fs24 \cf2 \cb1 \

\fs36 \cf7 \cb4 \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 \kerning1\expnd0\expndtw0 13. \expnd0\expndtw0\kerning0
Rust allows you to have 
\f2\b any number of immutable references
\f0\b0  as long as there are 
\f2\b no mutable references at the same time
\f0\b0 .\
let a = String::from("hellp");\
let b = &a;  // Immutable borrow\
println!("\{\}", a); // 
\f3 \uc0\u9989 
\f0  This works!\

\f4\fs24 \
\pard\pardeftab720\sa240\partightenfactor0
\cf0 \

\f0\fs36 14. Only one mutable reference, then no more immutable or mutable references allowed, until it is not used.\
15.\cf5  \cb8 let user1 = User\{name:name, age:age\};    // struct object\
16.  \cb6 You create a struct in Rust to organize and group related data into a single, custom data type. Structs allow you to package together multiple values\'97each potentially of different types\'97under one name, making your code more readable, maintainable, and type-safe.\
17. Adding functions implicit to a struct	\
\pard\pardeftab720\partightenfactor0

\f1\fs24 \cf5 \cb4 struct Rect \{\
    width : i32,\
    length : i32,\
\
\}\
\
impl Rect \{\
    fn area(&self) -> i32\{\
        self.width * self.length\
    \}\
\}\cf2 \cb1 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\fs36 \cf5 \cb6 \
18. Pattern matching helps you match some variants of enum and do some logic.\
\pard\pardeftab720\partightenfactor0

\f1\fs24 \cf5 \cb14 fn area(shape : Shape)->f32\{\
    match shape \{\
        Shape::Circle(radius)=> 3.14*radius*radius,\
        Shape::Rectangle(l, b)=> l*b,\
        Shape::Square(side)=>side*side,\
    \}\
\
\}\cb1 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\fs36 \cf0 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 19.  To flush out the output of the print before taking the input.\
io::stdout().flush().unwrap(); // Flush the output to display prompt immediately but if you are using println , then there is not need of this.\
\
20. Option enum\
enum Option<T> \{\
	Some(T),\
	None,\
\}\
\
}